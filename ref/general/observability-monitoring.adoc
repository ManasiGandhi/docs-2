:page-layout: general-reference
:page-type: general
:page-description: Observability helps you understand system behavior by processing and monitoring the data the system generates through metrics, logging, tracing, and health checks, to get the information you need to troubleshoot failure
:page-categories: MicroProfile
:seo-title: Observability helps you understand system behavior by processing and monitoring system data
:seo-description: Microservice architecture is a popular approach for building cloud-native applications in which each capability is developed as an independent service. It enables small, autonomous teams to develop, deploy, and scale their respective services independently.
= Observability and monitoring

Observability is the ability of a system to expose information about its internal state to facilitate problem determination, performance analysis and other investigations.

In a microservices environment, your application needs to be functional as a whole, though individual service instances can start or stop to adjust for capacity requirements or to recover from failure.
To monitor this fluid system each entity must provide appropriate data for problem detection, for example, metrics, tracing, and health checks.
Metrics collect numerical information from the application and platform, and logs collect textual information.
Tracing captures the end-to-end flow of a request through the system.
Health Checks help orchestrators perform automated actions to maintain overall system health.

== Metrics

Metrics are numerical measurements that are captured and processed to identify and respond to potential issues before they escalate and cause more serious problems.
Metrics allow effective monitoring of microservices and can be used by operations teams when the microservices are running in production.
In distributed system metrics, there are three factors involved; producers, aggregators, and processors.

Metrics come in various forms, including counters, gauges, timers, histograms, and meters.
You can enable metrics in your Open Liberty application with the MicroProfile Metrics feature, which defines annotations that help you quickly build metrics into your code.

For a list of all available Open Liberty metrics, see the metrics reference list.
== Logs

Log messages are strings with contextual information that pertains to the state and activity of a microservice when the log entry is created.
Logs are required to diagnose how and why services fail. They play a supporting role to metrics in monitoring application health.
Handling log files requires more thought if a containerized application can't be configured to write logs to `standard out` or `standard err` streams.
You can use a volume for log data with a simple bind mount for local development and test, or a proper Persistent Volume as part of a Kubernetes deployment.
A dedicated sidecar or logging agent can read from a shared volume to forward logs to a centralized aggregator.
Log rotation must be configured explicitly to control the amount of log data stored on volumes.
Alternately, you can use application libraries or agents to forward logs directly to aggregators.
This option can carry some configuration complexity across deployment environments.

== Tracing

Distributed, request, or end-to-end tracing captures the end-to-end flow of a request through the system.
Distributed tracing is a technique that addresses logging information in microservice-based applications.
HTTP request tracing helps to determine how a request is being processed.
This includes authentication and the length of each step that was taken in the pipeline.
Tracing essentially captures both relationships between services, the services the request touched, and the structure of work through the system, synchronous or asynchronous processing, child-of or follows-from relationships.

== Health Checks

A health check is a special REST API implementation that you can use to validate the status of a microservice and its dependencies.
Services report as either `UP` or `DOWN` state by implementing the API provided by MicroProfile Health.
Health Checks, often custom HTTP endpoints, help orchestrators, like Kubernetes or Cloud Foundry, to perform automated actions to maintain overall system health.

A service has a health check API endpoint, for example `HTTP /health`, that returns the health of the service.
The API endpoint handler performs various checks, such as the status of the connections to the infrastructure services used by the service instance.
The status of the host, for example, disk space, and application specific logic.

A health check client; a monitoring service, service registry or load balancer, periodically invokes the endpoint to check the health of the service instance
