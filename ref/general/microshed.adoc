:page-layout: general-reference
:page-type: general
:page-description: MicroShed testing helps you to write integration tests using Testcontainers framework for Java microservice applications. With MicroShed testing you can test your Open Liberty application from outside the container so you are testing the exact same image that runs in production.
:page-categories: MicroShed testing
:seo-title: Testing in a container with MicroShed testing
:seo-description:  MicroShed testing helps you to write integration tests using Testcontainers for Java microservice applications. With MicroShed testing you can test your Open Liberty application from outside the container so you are testing the exact same image that runs in production.
= Testing microservice applications

MicroShed Testing is a Java library that helps you write true-to-production integration tests for your microservice applications with the  link:https://openliberty.io/blog/2019/03/27/integration-testing-with-testcontainers.html[Testcontainers] framework.
link:https://microshed.org/microshed-testing/[MicroShed Testing] framework analyzes your application from outside the link:https://www.docker.com/why-docker[Docker] container without accessing the application internals.

Integration tests are more comprehensive than unit tests.
However, integration tests can be more complicated and take longer to run.


== Why integration testing

You need to be sure that your application works as well in production as it does in the development environment.
Integration tests assess multiple test classes and components, but take longer and can be complicated to set up and configure.
With shorter development cycles and limited time available, developers often run unit tests because they are easier and faster.
MicroShed Testing framework streamlines your integration tests with the Testcontainers library for a better workflow.

== Development-production parity

Development-production parity, or dev/prod parity, is one of the factors in the link:https://12factor.net/[twelve-factor app], a methodology to build modern applications.
The idea behind dev/prod parity is to keep the development, staging, and production environments as similar as possible in terms of time, personnel, and tools.
To simplify the development process, developers often use different tools in development than they do in production.
For example, you might use a local Maven build in development, but the application might be deployed to a Docker container in production.
Differences between the environments can cause a test to fail in production, even though it passed in development.
The application might work on your computer but not in production.
So it is important to use the same services in development as in production.
MicroShed Testing framework helps achieve dev/prod parity because it tests the application by using the same environment that is used in production.

== Using MicroShed Testing

You can easily deploy your microservices in different environments by using containers.
Containers are convenient and combine everything that you need to run a service into a single unit.
They are lightweight, disposable, configurable, and manageable with an orchestration software like Kubernetes.
You can leverage containers in a test environment by using the Testcontainers framework, which is an open source library that supports JUnit tests.
Microshed Testing is a Java library for MicroProfile and Java EE developers to test their applications in an environment similar to production.

With MicroShed Testing framework, you can write an integration test that looks something like this:

[source, java]
----
@MicroShedTest
public class BasicJAXRSServiceTest
----

The @MicroShedTest annotation searches for a Dockerfile in the repository, starts up the application in a Docker container, and waits for it to be ready before starting the tests.

    @Container
    public static ApplicationContainer app = new ApplicationContainer()
                    .withAppContextRoot("/myservice");

The @Container annotation injects a REST _Client_ proxy of the PersonService, which allows you to easily invoke HTTP requests on the running application container.

    @RESTClient
    public static PersonService personSvc;

    @Test
    public void testGetPerson()

The @RESTClient annotation invokes an HTTP POST request to the running container, which triggers the PersonService#createPerson endpoint and returns the generated ID
        Long bobId = personSvc.createPerson("Bob", 24);

By using the generated ID, invoke an HTTP GET request to read the record that was created. The JSON response automatically converts to a `Person` object by using JSON-B.

        Person bob = personSvc.getPerson(bobId);

        assertEquals("Bob", bob.name);
        assertEquals(24, bob.age);
        assertNotNull(bob.id);


    @Test
    public void testGetUnknownPerson()

The @Test annotation invokes an HTTP GET request to get a person with ID -1, which does not exist
         and asserts that the application container returns an HTTP 404 (not found) exception

        assertThrows(NotFoundException.class, () -> personSvc.getPerson(-1L));


Ready to try MicroShed Testing to test a MicroProfile or Jakarta EE application? Check out the guide https://openliberty.io/guides/microshed-testing.html[Testing a MicroProfile or Jakarta EE application]
